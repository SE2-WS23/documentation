The purpose of this document is to provide a comprehensive understanding of the rationale behind the selection of the technology stack for our project. The chosen technologies are expected to provide a balance between familiarity, industry standards, performance, and future scalability. Additionally, we tried to balance between time being spent to learn the new technology and the benefit it will provide our Project to ensure the project can be completed to the best of our abilities within the time constraints given.

## Active Tech Stack
Technologies we are currently using in our project:
### Front-end Library: **React**
**Familiarity:** React is chosen as the front-end library due to its familiarity among the development team. This familiarity reduces the learning curve and accelerates development.
**Industry Standard:** React has emerged as an industry standard for building modern user interfaces. This ensures that the skills acquired while working with React are transferable and valuable in the broader tech landscape.

### Database: **PostgreSQL**

**Familiarity and Performance:** PostgreSQL is selected as the database due to its proven performance and the team's existing familiarity with SQL Databases. Its robust feature set and reliability make it a suitable choice for our project's data storage needs.

### Backend Language: **Python**

**Industry Standard:** Python is chosen as the backend language because of its prominence in the field of machine learning. 
**Familiarity:** The team is required to learn this language for another course as well reducing the downside of time needed to learn the language.

### Backend Framework: **Flask**

**Learning Efficiency:** Flask is selected as the backend framework due to its simplicity and ease of learning. This allows the team to rapidly acquire the necessary skills and focus on project development rather than spending excessive time on mastering the intricacies of of python.

### Object-Relational Mapping (ORM): **Prisma**

**Modern and Efficient:** Prisma is chosen as the ORM for its modern approach to database access and ease of use. It provides a type-safe and auto-generated query API, enhancing developer productivity and reducing the likelihood of runtime errors.

### Cloud Platform: **Google Cloud**

**Peer Recommendation:** Google Cloud was selected based on a recommendation from a team member. Leveraging a cloud platform is essential for scalability and reliability, and the recommendation adds an element of guidance and support from someone with practical experience.

### Architecture: **Microservices with Gateway**
**Scalability:** The decision to introduce microservices architecture is motivated by the project's scalability requirements. Microservices provide a modular and scalable approach to building applications, enabling independent deployment and scaling of individual services based on demand.

**Valuable Learning Opportunity:** The inclusion of a microservice architecture is seen as a valuable learning opportunity for the team. It has never been used by any team member and is a popular architecture to build scalable and modular products. Additionally, Learning to implement and work with a gateway contributes to the team's understanding of scalable and maintainable architectural patterns.


### Project Management Tool: **GitHub Projects**

**Cost-Effectiveness:** GitHub Projects is chosen as the new project management tool (over Jira) due to its cost-effectiveness (free).
**Single Point of Truth:**  Utilizing GitHub Projects as a single point of truth streamlines task management, issue tracking, and project progress within the familiar GitHub environment.
## Dropped Technologies
Technologies that were considered but did not make the cut:
### temporal.io

**Complexity:** After careful consideration, the team decided to drop temporal.io from the technology stack. The complexity associated with temporal.io and its feature set were deemed to be overkill for the current project requirements.

### Jira

**Pricing:** We migrated from Jira to GitHub Projects because Jira is to expensive for the budget our team has.


